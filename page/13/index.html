<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>My real name is Tạ Minh Luận</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="My real name is Tạ Minh Luận">
<meta property="og:url" content="https://taminhluan.github.io/page/13/index.html">
<meta property="og:site_name" content="My real name is Tạ Minh Luận">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My real name is Tạ Minh Luận">
  
    <link rel="alternate" href="/atom.xml" title="My real name is Tạ Minh Luận" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My real name is Tạ Minh Luận</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://taminhluan.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-blog-wolfram-alpha-su-dot-pha-ve-giai-thuat-tri-thuc-co-ban-va-cong-nghe-tri-tue-nhan-tao" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-wolfram-alpha-su-dot-pha-ve-giai-thuat-tri-thuc-co-ban-va-cong-nghe-tri-tue-nhan-tao/" class="article-date">
  <time datetime="2018-12-07T10:48:20.000Z" itemprop="datePublished">2018-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tri-tue-nhan-tao/">Trí tuệ nhân tạo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-wolfram-alpha-su-dot-pha-ve-giai-thuat-tri-thuc-co-ban-va-cong-nghe-tri-tue-nhan-tao/">Wolfram alpha - Sự đột phá về giải thuật, tri thức cơ bản và công nghệ trí tuệ nhân tạo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Trước mình học một khóa Machine Learning Fundamental trên công ty. Khi thầy bảo tính đạo hàm (để dùng cho gradient descent). Mọi người bắt đầu tính. Mình thì tra bảng đạo hàm cơ bản. Còn một chị trong lớp thì bảo dùng **<a href="https://www.wolframalpha.com/" target="_blank" rel="noopener">Wolfram Alpha</a>. **Lúc đó mình không biết đó là cái gì. Còn chả biết viết như nào :D. Chỉ mơ hồ đoán nó là một công cụ tính toán gì đó rất mạnh còn giải được hệ phương trình. Tính đạo hàm các thứ… Chắc có nhiều bạn đã biết, đối với mình thì nó mới. Nay tình cờ mình lại đọc được về nó. Mục đích bài viết là để giới thiệu từ khóa wolfram alpha.</p>
<p>Compute expert-level answers using Wolfram’s breakthroughalgorithms, knowledgebase and AI technology</p>
<h3 id="Wolfram-Alpha-la-gi"><a href="#Wolfram-Alpha-la-gi" class="headerlink" title="Wolfram Alpha là gì"></a>Wolfram Alpha là gì</h3><p>Thử hỏi nó xem nó tên gì, bao nhiêu tuổi và hoạt động thế nào. <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/volframalpha-what-is-your-name.png" alt></p>
<h2 id="Input-interpretation"><a href="#Input-interpretation" class="headerlink" title="Input interpretation:"></a>Input interpretation:</h2><p><img src="https://www5b.wolframalpha.com/Calculate/MSP/MSP559116221ab1g73b201900002b9iai7d70if322i?MSPStoreType=image/gif&s=45" alt="How old is Wolfram|Alpha?"></p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response:"></a>Response:</h2><p><img src="https://www5b.wolframalpha.com/Calculate/MSP/MSP559316221ab1g73b201900001a6iic426g342965?MSPStoreType=image/gif&s=45" alt="9 years 6 months 23.13 days (right now)"></p>
<p>Nó đã được 9 năm. Các bài viết về nó toàn từ hồi 2009.</p>
<h2 id="Input-interpretation-1"><a href="#Input-interpretation-1" class="headerlink" title="Input interpretation:"></a>Input interpretation:</h2><p><img src="https://www5b.wolframalpha.com/Calculate/MSP/MSP48301e73aii394c4b4b30000172a71e89gaahbf4?MSPStoreType=image/gif&s=36" alt="What&#39;s inside Wolfram|Alpha?"></p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result:"></a>Result:</h2><p><img src="https://www5b.wolframalpha.com/Calculate/MSP/MSP48321e73aii394c4b4b30000122ia5c0i5a77i6g?MSPStoreType=image/gif&s=36" alt="Wolfram|Alpha is powered by the Wolfram Language"></p>
<p>Ok nó được làm bằng thứ gì đó gọi là Wolfram Language.</p>
<p>Hỏi xem nó biết gì về albert einstein không?</p>
<p><img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/volframalpha-albert-einstein.png" alt></p>
<h3 id="Cac-linh-vuc-wolfram-alpha"><a href="#Cac-linh-vuc-wolfram-alpha" class="headerlink" title="Các lĩnh vực wolfram alpha"></a>Các lĩnh vực wolfram alpha</h3><p><img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/volframalpha-domain.png" alt> Chúng ta xem toán học có gì. Có vẻ toán học là cái nó mạnh nhất hoặc vật lý vì người tạo ra nó là nhà vật lý học. Đạo hàm thử xem có như lời đồn không. <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/derivative.png" alt></p>
<h3 id="Wolfram-Language"><a href="#Wolfram-Language" class="headerlink" title="Wolfram Language"></a>Wolfram Language</h3><p>Wolfram language là ngôn ngữ máy tính (computer language). Nó cho bạn cách để giao tiếp với máy tính. Cụ thể là bạn nói cho nó biết cái mà nó làm. Có rất nhiều ngôn ngữ máy tính như C++, Java, Python và Javascript. Wolfram language là độc nhất với hiểu biết cơ bản của nó (<em>knowledge based</em>). Nghĩa là nó đã biết nhiều rồi, bạn cần phải nói cho nó ít nhiều cái bạn muốn. Bạn có thể làm mọi thứ trực quan, tương tác, nhiều thứ khác. Bạn có thể phân tích, mô phỏng các thứ. Bạn có thể tạo ứng dụng, chương trình và các website. Bạn có thể lên ý tưởng và implement chúng trên máy tính, điện thoại, các thiết bị nhúng nhỏ và nhiều hơn nữa. Wolfram language được xây dựng hơn 30 năm từ Mathematica được sử dụng rộng rãi trong nghiên cứu.</p>
<h3 id="Thuc-hanh-su-dung-Wolfram-Language"><a href="#Thuc-hanh-su-dung-Wolfram-Language" class="headerlink" title="Thực hành sử dụng Wolfram Language"></a>Thực hành sử dụng Wolfram Language</h3><p>Cách tốt nhất đề học Wolfram Language là sử dụng nó. <a href="http://www.wolfram.com/programming-lab/" target="_blank" rel="noopener">Wolfram Programming Lab</a> dễ dàng truy cập và học ngôn ngữ này, hoặc bạn có thể sử dụng các môi trường tương tác Wolfram Language khác (chắc có cái IDE nào đó không rõ).</p>
<h3 id="Tac-gia"><a href="#Tac-gia" class="headerlink" title="Tác giả"></a>Tác giả</h3><p>Copy từ  <a href="https://dongtac.hncity.org/?Co-quy-tac-de-hieu-moi-the-gioi-thuc-tai-1" target="_blank" rel="noopener">https://dongtac.hncity.org/?Co-quy-tac-de-hieu-moi-the-gioi-thuc-tai-1</a> Wolfram là người Anh gốc Do Thái, sinh 1959 tại London. Ông cho rằng mọi hiện tượng trong vạn vật từ vũ trụ đến thị trường chứng khoán đều có thể quy về những chương trình tin học đơn giản và mọi hiện tượng phức tạp đều là kết quả phát triển của những tế bào ban đầu gọi là các tế bào autômát (viết tắt là CA - cellular automaton). Stephen Wolfram là một thần đồng có công trình khoa học từ khi 16 tuổi, nghiên cứu vật lý các hạt cơ bản, vũ trụ, toán học, tin học,… tác giả của Mathematica (hình 1), một phần mềm toán học tượng trưng nổi tiếng được sử dụng trên toàn thế giới. Wolfram sáng lập tập đoàn phần mềm hàng đầu Wolfram Research, Inc. có trên 2 triệu người sử dụng Mathematica. Các phiên bản mới của Mathematica liên tục bảo đảm cuộc sống của hơn 300 người trong công ty Wolfram Research, Inc. Wolfram nhiều năm suy nghĩ về một câu hỏi lớn: mọi cấu trúc phức tạp và đa dạng trong thế giới thực tại đã hình thành như thế nào? Liệu thiên nhiên có sử dụng một số quy tắc nào trong khi sáng tạo ra mọi vật, liệu có một khoa học lý thuyết nào để mô tả những quy tắc này? Trong thời gian sau này Wolfram rời quản lý công ty để chuyên nghiên cứu về CA và năm 2002 công bố cuốn sách Một loại hình khoa học mới [<a href="https://dongtac.hncity.org/?Co-quy-tac-de-hieu-moi-the-gioi-thuc-tai-1#nb1" title="Stephen Wolfram, A New Kind of Science: NKS | ON LINE, 2007" target="_blank" rel="noopener">1</a>] dày 1280 trang, rất sớm trở thành hiện tượng trong giới khoa học (hình 2). Khi nói đến cuốn sách này người ta không thể không nói đến phần mềm Mathematica, cơ sở tính toán cho NKS [<a href="https://dongtac.hncity.org/?Co-quy-tac-de-hieu-moi-the-gioi-thuc-tai-1#nb2" title="Stephen Wolfram, Mathematica" target="_blank" rel="noopener">2</a>]. Wolfram tin rằng tồn tại một chương trình rất đơn giản, được chạy trong một thời gian rất dài và dẫn đến mọi sự phức tạp trong vũ trụ: các sao, mặt trời, khí hậu, các sinh vật, các dòng chảy của chất lỏng, thị trường chứng khoán… Và chương trình đó chính là lý thuyết tối hậu của vật lý.</p>
<h3 id="Y-kien-khac"><a href="#Y-kien-khac" class="headerlink" title="Ý kiến khác"></a>Ý kiến khác</h3><p>Cũng có những bài viết, bình luận về wolfram alpha. Copy từ <a href="https://ictnews.vn/internet/wolfram-alpha-chi-la-hu-danh-18322.ict" target="_blank" rel="noopener">đây</a>. Wolfram Alpha không phải là một cỗ máy tìm kiếm thông thường. Nó chiếm không gian ở giữa Google và Wikipedia nên sự thành công của Wolfram Alpha là một điều rất đáng nghi ngờ. Tuy nhiên, nếu bạn cần một câu trả lời ngắn gọn (với điều kiện Wolfram Alpha có thể hiểu  được câu hỏi) thì đây là một công cụ hữu ích. <strong>Darien Graham – Smith</strong> (website PC Pro): “Wolfram Alpha sẽ tốt nếu bạn là một nhà nghiên cứu và cần những số liệu thống kê. Nó có rất ít tác dụng  với những người khác, ít nhất là cho đến thời điểm này”  - <strong>simonbarker *<em>(Phóng viên công nghệ - Mỹ). “Tồi tệ khủng khiếp! Hầu như nó chẳng hiểu bất cứ một lệnh tìm kiếm nào” - *</em>GwangjuSam</strong> “Wolfram Alpha = rác, liệu đến phiên bản tới có tốt hơn không?”-  <strong>dpoyser</strong>.</p>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Mình cảm thấy wolfram alpha rất tuyệt vời. Bản thân mình rất muốn có thể làm được một hệ thống như vậy (mình nói muốn nhé, còn mình là một thằng vớ vẩn). Một con trợ lý hiểu biết tất cả. Wolfram alpha còn có phần dành cho nhà phát triển call api. Quá tuyệt vời phải không làm được một ứng dụng giải toán. Tra cứu nhanh mọi thứ. Cám ơn các bạn.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-wolfram-alpha-su-dot-pha-ve-giai-thuat-tri-thuc-co-ban-va-cong-nghe-tri-tue-nhan-tao/" data-id="ck74jjguv00dl2mcpexifkfgu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-gioi-thieu-pre-calculus-sach-pre-calculus-workbook-for-dummies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-gioi-thieu-pre-calculus-sach-pre-calculus-workbook-for-dummies/" class="article-date">
  <time datetime="2018-12-06T19:42:05.000Z" itemprop="datePublished">2018-12-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pre-Calculus/">Pre Calculus</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-gioi-thieu-pre-calculus-sach-pre-calculus-workbook-for-dummies/">Giới thiệu pre calculus - Sách Pre calculus workbook for Dummies</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Có thể bạn đi sau, đi chậm hơn bạn bè nhưng không sao cả, quan trọng là cái đích bạn hướng tới. Can đảm lên bạn nhé</p>
</blockquote>
<h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Kiến thức căn bản toán của mình đã rơi rụng gần hết. Và trước giờ mình cũng không đọc tài liệu tiếng anh. Đây sẽ là thời điểm mà mình phải ôn lại một cách nghiêm túc. Để bắt đầu chúng ta cùng học cuốn <a href="https://drive.google.com/open?id=1CW8Gcp39GDhemqVvCFERS8ItDmSkmR3I" target="_blank" rel="noopener">pre calculus workbook for dummies</a>. Chúng ta đi từ đơn giản trước không nặng về toán để làm quen dần và các thuật ngữ tiếng anh. Chúng ta quay lại điểm bắt đầu của bắt đầu. Việc vừa học vừa viết lại thế này sẽ rất lâu nhưng sẽ nhớ lâu hơn.</p>
<h2 id="Pre-calculus-workbook-for-Dummies"><a href="#Pre-calculus-workbook-for-Dummies" class="headerlink" title="Pre calculus workbook for Dummies"></a>Pre calculus workbook for Dummies</h2><ul>
<li><a href="http://35.196.17.90/blog/gioi-thieu-pre-calculus-sach-pre-calculus-workbook-for-dummies/" target="_blank" rel="noopener">Introduction</a></li>
<li>Part I: Foundation (And We Don’t Mean Makeup!)</li>
<li>Part II: Trig Is the Key: Basic Review, the Unit Circle, and Graphs</li>
<li>Part III: Advanced Trig: Identities, Theorems, and Applications</li>
<li>Part IV: And the Rest</li>
<li>Part V: The Part of Tens</li>
</ul>
<h3 id="Ve-quyen-sach-nay"><a href="#Ve-quyen-sach-nay" class="headerlink" title="Về quyển sách này."></a>Về quyển sách này.</h3><p>Đừng để pre-cal làm bạn sợ. Khi bạn nhận ra rằng bạn đã biết tất cả chỉ là Đại số I và II (Algebra), bạn sẽ nhìn thấy rằng pre-cal là thực sự chỉ sử dụng các thông tin cũ theo cách mới. Và mặc dù nếu bạn đã sợ, chúng tôi ở đây với bạn, vì thế không cần hoảng loạn. Trước khi bạn sẵn sàng để bắt đầu một cuộc phiêu lưu mới, bạn cần biết một vài thứ về cuốn sách này. Cuốn sách không phải là tiểu thuyết. Nó không có nghĩa là đọc từ đầu tới cuối. Bạn có thể đọc từ bất kỳ chủ đề nào ở bất kỳ thời điểm nào, nhưng chúng tôi đã cấu chúng theo cách mà đi theo chương trình giáo dục bình thường. Điều này là khó để làm bởi vì một vài vùng không có pre-calc. Chúng ta sẽ xem chương trình giảng dạy, và sẽ trình bày như một khóa học. Thỉnh thoảng, chúng tôi có thể liên kết phần toán trong các chương khác và chúng tôi gửi cho bạn rất nhiều thông tin. Thay vì đặt cuốn sách trên giá và không bao giờ nhìn lại nó, hãy sử dụng nó như một cái chặn cửa. Chúng tôi gợi ý bạn đi theo một trong hai cách:</p>
<ul>
<li>Tìm kiếm cái bạn cần để biết khi bạn cần tới nó.</li>
<li>Bắt đầu từ đầu và đọc xuyên suốt. Theo cách này bạn sẽ được nhắc lại các chủ đề cũ mà đã quên (bất cứ thứ gì về toán trong đầu bạn). Bên cạnh đó hãy thực hành cho tốt.</li>
</ul>
<h3 id="Loi-gia-su-kho-dai"><a href="#Loi-gia-su-kho-dai" class="headerlink" title="Lời giả sử khờ dại"></a>Lời giả sử khờ dại</h3><p>Chúng tôi không mong rằng bạn yêu toán theo cách mà chúng tôi làm như một chuyên gia (professional math geeks). Chúng tôi giả sử rằng bạn đã chọn quyển sách này vì lý do riêng của bạn. Có lẽ bạn muốn xem qua về một khóa học trước khi bạn lấy nó, hoặc có lẽ bạn cần phải khởi động lại chủ đề trong khóa học này, hoặc có lẽ con bạn đang học khóa này và bạn cần cố gắng đề giúp cậu bé thành công. Dù gì đi nữa, chúng tôi giả sử bạn đã gặp phải các chủ đề này trước đây, bởi nó là các phần thông dụng, các chủ đề sẽ được xem lại một lượt và bạn sẽ gặp lại trong Đại số và Hình học(<strong>algebra or geometry</strong>).</p>
<h3 id="Cach-to-chung-cua-sach"><a href="#Cach-to-chung-cua-sach" class="headerlink" title="Cách tổ chứng của sách"></a>Cách tổ chứng của sách</h3><p>Cuốn sách này được chia thành năm phần, trình bày các chủ đề được dạy trong môn pre-calc. Phần 1: Khởi đầu. Trong các chương của phần I, khởi đầu của khởi đầu. Trước hết chúng tôi sẽ ôn lại các khái niệm ở môn Đại số II. Chúng tôi sẽ bao gồm các số thực và cái mà bạn được hỏi để làm việc với chúng. Tiếp theo là các loại functions (polynomials, rational, exponential, and logarithmic) Bậc cao, mũ và logarit. Các dạng đồ thị của chúng và performing operations với chúng Phần 2: Trig 1s the key (không dịch được): Basic review the Unit Circle và đồ thị Đến phần đọc chương hai mình sẽ có vốn đề dịch lại phần này.</p>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Cám ơn các bạn đã theo dõi!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-gioi-thieu-pre-calculus-sach-pre-calculus-workbook-for-dummies/" data-id="ck74jjgrv006x2mcpw9261ndr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-text-to-speech-chuyen-van-ban-thanh-giong-noi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-text-to-speech-chuyen-van-ban-thanh-giong-noi/" class="article-date">
  <time datetime="2018-12-06T08:35:47.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Lap-trinh/">Lập trình</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-text-to-speech-chuyen-van-ban-thanh-giong-noi/">Text to speech - chuyển văn bản thành giọng nói</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Bài viết không liên quan tới machine learning. Chúng ta sẽ gọi api của fpt. Thằng bạn mình hỏi học machine learning có làm được chuyển văn bản thành giọng nói không. Mình bảo là không (vì mình không biết thật). Nhưng sau khi thấy nó nghe truyện mạng với chị google (bản thân mình không có hứng thú với truyện ngôn tình hay kiếm hiệp và có thì chắc mình cũng đọc chữ) thì mình nghĩ kiếm cho nó cái api nào cho nó dùng. Nó có bảo mình phải tạo model machine learning đâu. Ở bài viết này mình sẽ hướng dẫn cho các bạn tạo app text to speech. Có luôn source code để các bạn tải về dùng miễn phí hoàn toàn. Các bạn có thể dùng để nghe truyện, đọc báo hoặc tạo giọng nói cho nhà thông minh, chatbot của bạn chẳng hạn rất tiện phải không. Đây là một đoạn của google translate [audio mp3=”<a href="http://35.196.17.90/blog/wp-content/uploads/2018/12/translate_tts.mp3&quot;\]\[/audio\]" target="_blank" rel="noopener">http://35.196.17.90/blog/wp-content/uploads/2018/12/translate_tts.mp3&quot;\]\[/audio\]</a> Đây là api fpt [audio mp3=”<a href="http://35.196.17.90/blog/wp-content/uploads/2018/12/full.mp3&quot;\]\[/audio\]" target="_blank" rel="noopener">http://35.196.17.90/blog/wp-content/uploads/2018/12/full.mp3&quot;\]\[/audio\]</a>   Đây là phần giới thiệu của fpt Tổng hợp tiếng nói (Speech synthesis) là bài toán cơ bản trong bài toán lớn về giao tiếp giữa người và máy (Human-Machine Interface). Với tham vọng riêng của mình, Ban công nghệ FPT (FTI) đã nỗ lực nghiên cứu suốt gần 5 năm qua để cho ra mắt sản phẩm FPT Speech Synthesis. Sản phẩm là sự kết hợp của:</p>
<ul>
<li>Ngôn ngữ học (Linguistics): âm vị học (Phonology), hình thái học (Morphology), ngữ dụng học (Pragmatics)</li>
<li>Vật lý học: âm học</li>
<li>Công nghệ: Xử lý ngôn ngữ tự nhiên (Natural Language Processing) , học máy (Machine Learning), xử lý tín hiệu số (Digital Signal Processing)</li>
</ul>
<p>Được đánh giá là hệ thống tổng hợp tiếng nói tiếng Việt có chất lượng tốt nhất thị trường hiện nay, hệ thống tổng hợp tiếng Việt mới của FPT đang được mở trên Open FPT (<a href="http://openfpt.vn/" target="_blank" rel="noopener">http://openfpt.vn/</a>). Các nhà phát triển có thể khai thác nguồn tài nguyên này để xây dựng ứng dụng của riêng mình trên các nền tảng khác nhau. Cho đến thời điểm này, đã có nhiều sản phẩm như “Giao thông thông minh” do FPT IS phát triển, hệ thống thông báo thông tin tài chính của VHT, hệ thống sinh ra video tự động từ bái báo điện tử, … đang sử dụng Speech Synthesis API của Open FPT và nhận được rất nhiều phản hồi tích cực từ người dùng.</p>
<h2 id="Text-to-speech"><a href="#Text-to-speech" class="headerlink" title="Text to speech"></a>Text to speech</h2><p>Mình viết bằng python. Đầu tiên ta cần vào <a href="https://dev.openfpt.vn/" target="_blank" rel="noopener">https://dev.openfpt.vn/</a> đăng ký tài khoản và tạo key để dùng cho app. Ok có cả phần test luôn. Các bạn có thể thử để xem chất lượng giọng nói. Tài liệu ở <a href="https://docs.openfpt.vn/#speech-synthesis" target="_blank" rel="noopener">đây.</a> Chúng ta bắt đầu code.</p>
<h3 id="Khoi-tao-cac-tham-so"><a href="#Khoi-tao-cac-tham-so" class="headerlink" title="Khởi tạo các tham số"></a>Khởi tạo các tham số</h3><p>Keys xin phép được ẩn đi. Mình chẳng tiếc nhưng sợ đông người dùng các bạn làm chậm của nhau. May cho chúng ta có phần comment của thằng bạn mình. Source code ở phía cuối bài viết, mình cũng lười không làm cái ứng dụng giao diện tử tế. Quan trọng là ý tưởng phải không :D. Chúng ta dùng nhiều key bởi vì fpt sẽ chặn số lượng request tính trên phút. Mình sẽ thay đổi liên tục các keys để lack vụ này :D.</p>
<p>import sys<br>import requests</p>
<p>#API Key của bạn<br>keys = [<br>        ‘#############################’,<br>        ‘#############################’,<br>      ‘#############################’,<br>    ‘#############################’<br>]</p>
<p>#Xác định các giọng đọc, voice có các giá trị là leminh (giọng nam miền bắc), male (giọng nam miền bắc),</p>
<p>#female (giọng nữ miền bắc), hatieumai (giọng nữ miền nam), ngoclam (giọng nữ Huế)<br>voice = “leminh”<br># Xác định các giọng đọc, voice có các giá trị là:<br># leminh (giọng nam miền bắc nghe ấm ),<br># male (giọng nam miền bắc hơi già có tiếng thở),<br># female (giọng nữ miền bắc trẻ, giọng trong đọc hơi chậm so với các giọng khác),<br># hatieumai (giọng nữ miền nam nghe đk),<br># ngoclam (giọng nữ Huế  đọc hơi bị ngắt nên cho chậm lại)<br>speed= “0”</p>
<p>#ngữ điệu 1 on. 0 off<br>prosody= “0”</p>
<p>#phần dưới này để phục vụ cho việc nhận tham số từ cmd khi sử dụng file start.py<br># vd call file “start.py input” #input là input.txt lưu văn bản cần chuyển thành giọng nói<br># hoặc chỉnh sửa short_direct đối với dùng jupyter notebook<br># ngoài cách chạy command line có thể sử dụng jupyter notebook chủ yếu cho người phát triển<br>args = sys.argv<br>if len(args) &gt;= 1:<br>    short_direct = args[1]<br>    direc = ‘{}/‘.format(args[1])</p>
<p># Thay ten file<br>short_direct = ‘starttq’<br>direc = f’{short_direct}/‘</p>
<h3 id="Backup-file-mp3-truoc-do"><a href="#Backup-file-mp3-truoc-do" class="headerlink" title="Backup file mp3 trước đó"></a>Backup file mp3 trước đó</h3><p>Mục đích tránh ghi đè mất file mp3 ở đợt trước</p>
<p>import os<br>import datetime</p>
<p>#backup file full.mp3<br>if short_direct not in os.listdir():<br>    os.mkdir(short_direct)<br>if ‘full.mp3’ in os.listdir(‘{}’.format(direc)):</p>
<pre><code>#create folder backup if not exists
if &apos;backup&apos; not in os.listdir(&apos;{}&apos;.format(direc)):
    os.mkdir(&apos;{}backup&apos;.format(direc))

now = str(datetime.datetime.now()).replace(&quot; &quot;, &quot;_&quot;).replace(&quot;:&quot;, &quot;_&quot;)
os.rename(&quot;{}full.mp3&quot;.format(direc), &quot;{}backup/{}.mp3&quot;.format(direc, now))
print(&apos;backup file full mp3 to {}backup/{}.mp3&apos;.format(direc, now))</code></pre><p># Remove all file mp3<br>for item in os.listdir(‘{}’.format(direc)):<br>    if item.endswith(“.mp3”):<br>        os.remove(os.path.join(direc, item))<br>print(‘remove all file mp3’)</p>
<p>Kết quả <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/backup-file.png" alt></p>
<h3 id="Goi-API-va-tai-cac-file-nhac"><a href="#Goi-API-va-tai-cac-file-nhac" class="headerlink" title="Gọi API và tải các file nhạc"></a>Gọi API và tải các file nhạc</h3><p>Vì fpt giới hạn số lượng ký tự. Nên ta cần cắt ra thành nhiều đoạn. Cắt thế nào để không vào giữa một chữ (phải là “xin chào” chứ không thể cắt “xin ch” rồi file sau là “ào” được). Cách làm đơn giản là lấy 500 (giới hạn của fpt) lùi lại đến khi gặp dấu cách thôi rồi cắt từ đó. Mình để 480 cho chắc :D. Đối với python thì chúng ta có thư viện textwrap.</p>
<p>from textwrap import wrap<br>import time<br>import wget<br>import random<br>file = open(“{}.txt”.format(short_direct), “r”, encoding=”utf-8”)<br>content = file.read()</p>
<p>wraptexts = wrap(content, 480)</p>
<p>for i in range(len(wraptexts)):<br>    while True:<br>        try:<br>            text = wraptexts[i]<br>            api_key = random.choice(keys)<br>            print(‘\n’, api_key)<br>            url = “<a href="http://api.openfpt.vn/text2speech/v4?api\_key={}&amp;voice={}&amp;speed={}&amp;prosody={}&quot;.format" target="_blank" rel="noopener">http://api.openfpt.vn/text2speech/v4?api\_key={}&amp;voice={}&amp;speed={}&amp;prosody={}&quot;.format</a>(api_key, voice, speed, prosody)<br>            response = requests.post(url, data=text.encode(‘utf-8’), headers={‘voice’:voice, ‘speed’:speed, ‘prosody’:prosody})<br>            response = response.json()<br>            print(‘\n’, response[‘async’])
            file = response[‘async’]<br>            print(“downloading file {}/{} “.format(i+1, len(wraptexts)), “{}{:03}.mp3”.format(direc, i))<br>        except :<br>            time.sleep(1)<br>            continue<br>        break<br>    while True:<br>        try:<br>            wget.download(file, “{}{:03}.mp3”.format(direc, i))<br>        except :<br>            time.sleep(0.1)<br>            print(‘Co loi. Thu lai’, end=’’)<br>            continue<br>        break</p>
<p>print(‘\nCOMPLETE’)</p>
<p>Kết quả: <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/download-files.png" alt></p>
<h3 id="Gop-files"><a href="#Gop-files" class="headerlink" title="Gộp files"></a>Gộp files</h3><p>Sau bước trên ta đã tải được các file đơn bây giờ gộp lại. Trên linux thì mình nhớ có sẵn lệnh split và merge file rồi. Trước mình đã thử chia nhỏ ảnh của mình và merge lại vẫn dùng được. Còn trên windows thì không có mình dùng một cái ffmpeg để merge file audios. Còn tải ở đâu thì mình không nhớ, các bạn có thể xem tài liệu <a href="https://trac.ffmpeg.org/wiki/Concatenate" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/Concatenate,</a> hoặc tải 3 file exe ở phần sourcecode.</p>
<p>#create list for merge<br>import subprocess<br>f = open(“{}create_list.bat”.format(direc), “w”)<br>f.write(“(for %%i in (*.mp3) do @echo file ‘%%i’) &gt; list.txt”)<br>f.close()<br>s = “{}create_list.bat”.format(direc)<br>os.chdir(short_direct)<br>print(os.listdir())<br>print(s)</p>
<p># os.system(“create_list2.bat”.format(direc))<br>subprocess.Popen(“create_list.bat”)<br>os.chdir(‘..’)</p>
<p>#merge file for create </p>
<p>#output: full.mp3<br>p = subprocess.run(‘ffmpeg -f concat -safe 0 -i {}list.txt -c copy {}full.mp3’.format(direc, direc))</p>
<p>Vậy là xong. Bạn muốn thưởng thức thì quay lại phần đầu mở audio lên.</p>
<h3 id="Cach-su-dung"><a href="#Cach-su-dung" class="headerlink" title="Cách sử dụng"></a>Cách sử dụng</h3><p>Có hai cách:</p>
<ul>
<li>Mở jupyter notebook. Vào cell &gt; Run all nhớ chỉnh short_direct trong code.</li>
</ul>
<p><img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/cell-runall.png" alt></p>
<ul>
<li>Dùng cmd: Vào thư mục&gt; start.py starttq. Với starttq.txt là nội dung văn bản.</li>
</ul>
<p><img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/starttq.png" alt> Kết quả cuối cùng là full.mp3 trong thư mục starttq. Nếu có file full.mp3 sẽ được backup vào thư mục backup.</p>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Cám ơn các bạn</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-text-to-speech-chuyen-van-ban-thanh-giong-noi/" data-id="ck74jjgur00dd2mcplv0qdgjm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-ham-lien-tuc-kha-vi-tap-xac-dinh-diem-dung-cuc-tri-gia-tri-lon-nhat-nho-nhat" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-ham-lien-tuc-kha-vi-tap-xac-dinh-diem-dung-cuc-tri-gia-tri-lon-nhat-nho-nhat/" class="article-date">
  <time datetime="2018-12-06T02:06:30.000Z" itemprop="datePublished">2018-12-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Toan-hoc/">Toán học</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-ham-lien-tuc-kha-vi-tap-xac-dinh-diem-dung-cuc-tri-gia-tri-lon-nhat-nho-nhat/">Hàm liên tục, khả vi, tập xác định, điểm dừng, cực trị, giá trị lớn nhất, nhỏ nhất</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><blockquote>
<p>Nhắc lại rằng giá trị lớn nhất và nhỏ nhất (nếu có) của một hàm số f0(x) f0(x) khả vi (và tập xác định là một <a href="https://en.wikipedia.org/wiki/Open_set" target="_blank" rel="noopener"><em>tập mở</em></a>) đạt được tại một trong các điểm cực trị của nó. Và điều kiện cần để một điểm là điểm cực trị là đạo hàm của hàm số tại điểm này f′0(x)=0 f0′(x)=0. Chú ý rằng một điểm thoả mãn f′0(x) f0′(x) = 0 thì được gọi là <em>điểm dừng</em> hay <em>stationary point</em>. Điểm cực trị là một điểm dừng nhưng không phải điểm dừng nào cũng là điểm cực trị. Ví dụ hàm f(x)=x3 f(x)=x3 có 0 0 là một điểm dừng nhưng không phải là điểm cực trị.</p>
</blockquote>
<p>Mình lấy một đoạn trong blog machinelearningcoban, bản thân mình quên sạch toán, còn không thể định nghĩa hàm, tập xác định, khả vi, điểm dừng cực trị, …. Mình sẽ tìm hiểu và viết trong bài này</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-ham-lien-tuc-kha-vi-tap-xac-dinh-diem-dung-cuc-tri-gia-tri-lon-nhat-nho-nhat/" data-id="ck74jjgrw006z2mcpyp9tnmg8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-machine-learning-hoat-dong-nhu-the-nao-than-thoai-va-su-that" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-machine-learning-hoat-dong-nhu-the-nao-than-thoai-va-su-that/" class="article-date">
  <time datetime="2018-12-04T13:03:24.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-learning/">Machine learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-machine-learning-hoat-dong-nhu-the-nao-than-thoai-va-su-that/">Machine Learning hoạt động như thế nào? Thần thoại và sự thật</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><blockquote>
<p>Every single computer you know today except Watson is a programmable system. Watson has now launched a third era IBM like to call it cognitive computing. Coginitive systems learn they are not programmed yet, cognitive system are more than machine learning system</p>
</blockquote>
<p>Mình tình cờ xem video robot <a href="https://www.youtube.com/watch?v=rXVoRyIGGhU&t=197s" target="_blank" rel="noopener">IBM Watson</a> và câu bên trên là một câu được robot nói. Các máy tính ngày nay bạn biết ngoại trừ Watson đều được lập trình tường minh. Watson mở ra một kỷ nguyên mới được gọi là cognitive computing. Cognitive systems học, chúng không phải lập trình, cognitive system nhiều hơn machine learning system. Bài dịch này không nhằm mục đích giới thiệu IBM Watson hay coginitive system (vì mình cũng không biết nó). Bài viết chỉ ra cái nhìn khác, mặt hạn chế của machine learning. Mình không cố giật tít, tiêu đề là mình dịch nguyên gốc.</p>
<h2 id="Machine-Learning-hoat-dong-nhu-the-nao-Than-thoai-va-su-that"><a href="#Machine-Learning-hoat-dong-nhu-the-nao-Than-thoai-va-su-that" class="headerlink" title="Machine Learning hoạt động như thế nào? Thần thoại và sự thật"></a>Machine Learning hoạt động như thế nào? Thần thoại và sự thật</h2><p>Đáp lại câu hỏi “Machine Learning hoạt động như nào?” Có rất nhiều huyền thoại: rằng nó học một cách tự động, rằng nó không yêu cầu phải tùy biến hay chỉnh sửa bởi các tổ chức sử dụng nó, rằng nó phù hợp với bất kỳ business nào và có thể giải quyết bất kỳ vấn đề nào. Nhưng liệu có đúng như vậy. Giống như bất kỳ công nghệ nào, Machine Learning có tiềm năng về business trong một vài trường hợp, nhưng không phải luôn luôn. Mặc dù được quảng cáo là tạo ra các máy tiếp thị công nghệ cao, nó thường không phải là giải pháp tốt nhất cho việc phân tích thông tin phi cấu trúc. Mặc dù các mà bạn <a href="https://www.kdnuggets.com/2016/08/artificial-intelligence-useful-technology-next-frankenstein.html" target="_blank" rel="noopener">nghe được</a>, nhưng nó không phải ngày hôm này, trong tương lai gần. Đây là sự thật mà (hầu hết) không có ai muốn nói về nó. Như đã giải thích trong <a href="https://www.expertsystem.com/truth-machine-learning-deep-learning-2/" target="_blank" rel="noopener">bài viết này,</a> machine learning là “một cách khác của việc lập trình máy tính thực thi một tác vụ;” vì thế trước khi hỏi “machine learning làm việc như thế nào?”. Nó rất quan trọng để thiết lập lại kỳ vọng đúng đắn về tiềm năng của machine learning trong business, nhớ rằng nó không phải là thứ phép thuật hay thứ gì đó mới mẻ. Và mặc dù nó gây ấn tượng(hiểu lầm) rằng máy tính có thể nhanh chóng trở nên thông minh (trong hoặc vượt ra ngoài trình độ của loài người, cảm ơn trí tuệ nhân tạo).</p>
<h3 id="Dac-trung-cua-machine-learning-va-gioi-han-cua-chung"><a href="#Dac-trung-cua-machine-learning-va-gioi-han-cua-chung" class="headerlink" title="Đặc trưng của machine learning (và giới hạn của chúng)"></a>Đặc trưng của machine learning (và giới hạn của chúng)</h3><p>Mặc dù có một số kĩ thuật machine learning, tất cả chúng đều chung phần lõi thống kê. Nói một cách đơn giản (In layman’s terms), Machine learning không nhúng hiểu biết, nó yêu cầu tập tài liệu cho training (một  tập tài liệu lớn hơn thì tốt hơn). Tập training phải được đánh dấu thủ công bởi con người vì thế thuật toán có thể ghi lại cái gì có trong tài liệu. Đây là lý do tại sao machine learning không thể tự nó làm mọi thứ… Rất nhiều công việc chân tay sẽ được yêu cầu trong bất kỳ kịch bản nào! Để học hay nhận dạng tài liệu liên quan tới chủ đề, kĩ thuật machine learning phải nuốt vào một số lượng lớn các tài liệu liên quan tới chủ đề đó. Nó cũng phải được gắn thẻ thủ công một lượng lớn tài liệu cái chứa chủ đề và một lớn tương tự không chứa chủ đề đó. Chỉ sau quá trình xử lý nhiều tài liệu đồng thời và tần xuất các từ khóa hệ thống sẽ nhận ra được chủ đề của tài liệu. Độ chính xác của hệ thống đã được train sẽ thay đổi dựa trên số lượng tài liệu được sử dụng trong suốt quá trình train và bao quát các tài liệu này. Hệ thống cũng thường xuyên phải train lại để duy trì chất lượng hệ thống. Sự quá tải thông tin sẽ làm chậm cả hệ thống, trong khi quá khớp (quá nhiều hệ thống cùng thể loại) sẽ khiến cho độ chính xác thấp. Nói cách khác tài liệu sai sẽ là lý do khiến chất lượng giảm Trong một  <a href="https://www.wired.com/2016/05/the-end-of-code/" target="_blank" rel="noopener">article</a> nổi tiếng, chúng tôi đọc rằng “với machine learning, các kĩ sư không bao giờ biết đúng tuy nhiên máy tính lại hoàn thành được tác vụ của nó”. Neural networks hoạt động mờ mịt và không thể hiểu được, một cách nói khác “black box”. Nghĩa là vấn đề cải thiện bị giới hạn, và nó thường khó để hiểu được tại sao hệ thống lại cải thiện hay làm cách nào bạn cải thiện nó. Trong hệ thống machine learning, đơn giản là không có công cụ nào để với cái để lọc giải thuật. Với machine learning thuần, chỉ một sự lựa chọn bạn có là thử thật nhiều giải thuật khác nhau. Không may, điều này không đảm bảo rằng bạn sẽ cải thiện được kết quả và đạt tới độ chính xác yêu cầu. Nếu có bất kỳ sai lầm nào được phát hiện hoặc hệ thống cần phải sửa đổi vì bất kỳ lý do gì, quá trình lại quay về điểm bắt đầu.</p>
<h3 id="Tu-machine-learning-den-Cognitive-AI"><a href="#Tu-machine-learning-den-Cognitive-AI" class="headerlink" title="Từ machine learning đến Cognitive AI"></a>Từ machine learning đến Cognitive AI</h3><p>Trở lại với câu hỏi đầu tiên của chúng ta “machine learning hoạt động như nào?” Chúng ta có thể nói rằng machine learning hỗ trợ tổ chức khi chúng ta có đủ số lượng tài liệu để train và khi đó chúng ta có một kịch bản đơn giản. Đối với phân tích dữ liệu, ứng cử viên cho thuần machine learning chính xác là cái này: Trường hợp độ phức tạp thấp và tập dữ liệu training lớn với phân phối xác suất của các đầu ra cân bằng. Thay vào đó, khi tình hình mà một lượng nhỏ và không đồng đều các mẫu, độ phức tạp cao, machine learning là không đủ. Cho trường hợp này, bạn cần một <strong>linguistic enginem *<em>thứ đủ tinh vi để đảm bảo hiểu sâu vào nội dung và tập công cụ mạnh mẽ đủ để phát triển một ứng dụng *</em>advanced linguistic rules</strong> hiệu quả. Tập kĩ thuật Cogito cognitive cung cấp các luật cơ bản về cognitive technology và thuật toán dựa vào machine learning để giải quyết các vấn đề thường gặp về xử lý thông tin phi cấu trúc. Bao gồm phần lớn các kĩ thuật AI nâng cao như machine learning với thuật toán xử lý ngôn ngữ tự nhiên và ngữ nghĩa. Cogito đảm bảo là có hiệu quả cao cho mỗi tình hình. <a href="https://www.youtube.com/watch?v=l9bA9AjtRgI" target="_blank" rel="noopener">Xem video này</a> để hiểu sự khác biệt giữa Cogito và các công nghệ dựa trên machine learning và Làm thế nào để Cogito tạo ra giá trị cho business của bạn</p>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Mình đã cố gắng dịch sát nghĩa nhất, một số đoạn mình chưa hiểu lắm. Bạn có thể vào <a href="https://www.expertsystem.com/how-does-machine-learning-work/" target="_blank" rel="noopener">https://www.expertsystem.com/how-does-machine-learning-work/.</a> Bài viết quảng cáo cogito nhưng mình chưa thấy demo nào. Tóm lại machine learning không giải quyết được mọi vấn đề của doanh nghiệp, nó còn có các hạn chế. Ngoài machine learning, AI còn rất rộng còn có một thứ gọi là Cognitive computing. Đối với mình, kĩ thuật nào đều có hạn chế của nó, machine learning cũng vậy, nó không thể giải quyết được mọi vấn đề, không phải là true AI, nhưng nó đã giải quyết được rất nhiều bài toán thực tế. Còn cognitive system như IBM Watson là rất ấn tượng, nhưng có vẻ chưa được rõ ràng và cũng không có nhiều tài liệu nói về nó. Cảm ơn các bạn!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-machine-learning-hoat-dong-nhu-the-nao-than-thoai-va-su-that/" data-id="ck74jjgun00d32mcpt3p7nu8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-titanic-data-science-solutions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-titanic-data-science-solutions/" class="article-date">
  <time datetime="2018-12-04T08:03:44.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Deep-learning/">Deep learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-titanic-data-science-solutions/">Titanic Data Science Solutions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>TBD</p>
</blockquote>
<h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><h2 id="Titanic-Data-Science-Solutions"><a href="#Titanic-Data-Science-Solutions" class="headerlink" title="Titanic Data Science Solutions"></a>Titanic Data Science Solutions</h2><p>Tôi đã released một package <a href="https://speedml.com/" target="_blank" rel="noopener">Speedml</a>, làm cho các kĩ thuật được sử dụng trong notebook này trở nên trực quan, mạnh mẽ và ứng dụng. Speedml giúp tôi nhảy từ dưới 80% trên leaderboard của Kaggle lên trên 20%. Một điều nữa là Speedml làm được điều đó với chỉ 70% dòng code. Tải về và cài đặt <a href="https://github.com/Speedml/notebooks/blob/master/titanic/titanic-solution-using-speedml.ipynb" target="_blank" rel="noopener">Titanic Solution using Speedml</a>. Notebook đi cùng với cuốn sách <a href="https://www.amazon.com/Data-Science-Solutions-Startup-Workflow/dp/1520545312" target="_blank" rel="noopener">Data Science Solutions</a>. Notebook này sẽ đi qua các công việc thường làm cho việc giải quyết một cuộc thi Data Science tại Kaggle. Có một vài notebook tuyệt vời để học data science trong các cuộc thi. Tuy nhiên, nhiều khi sẽ bỏ qua một vài giải thích trong việc phát triển giải pháp như là những notebook đó là giành cho chuyên gia với nhau. Nhiệm vụ của notebook này là làm từng bước từng bước, giải thích ở mỗi bước và lý do cho mỗi quyết định chúng ta làm trong việc giải quyết vấn đề.</p>
<h3 id="Cac-giai-doan"><a href="#Cac-giai-doan" class="headerlink" title="Các giai đoạn"></a>Các giai đoạn</h3><p>Một competition solution gồm 7 gia đoạn được mô tả trong Data Science Solutions book.</p>
<ol>
<li>Đặt câu hỏi hoặc định nghĩa các vấn đề</li>
<li>Thu được training và test data</li>
<li>Chuẩn bị data (Wrangle, prepare, cleanse)</li>
<li>Phân tích, nhận định và khám phá dữ liệu</li>
<li>Mô hình hóa, dự đoán và giải quyết vấn đề</li>
<li>Visualize, báo cáo và biểu diễn vấn đề ở các bước và giải pháp cuối cùng</li>
<li>Supply và Submit kết quả</li>
</ol>
<p>Bên trên là các bước thường làm. Tuy nhiên có một số trường hợp ngoại lệ.</p>
<ul>
<li>Chúng ta sẽ gộp nhiều giai đoạn. Chúng ta có thể phân tích bằng cách visualizing</li>
<li>Thực hiện một giai đoạn nào đó sớm hơn. Chúng ta có thể phân tích data trước khi quá trình wrangling</li>
<li>Thực hiện một giai đoạn nhiền lần. Visualize có thể được làm đi làm lại nhiều lần</li>
<li>Bỏ một số giai đoạn. Chúng ta có thể không cần Supply(mình chưa hiểu lắm).</li>
</ul>
<h3 id="Dat-cau-hoi-va-dinh-nghia-van-de"><a href="#Dat-cau-hoi-va-dinh-nghia-van-de" class="headerlink" title="Đặt câu hỏi và định nghĩa vấn đề"></a>Đặt câu hỏi và định nghĩa vấn đề</h3><p>Các cuộc thi trên Kaggle định nghĩa vấ đề cần phải giải quyết trong khi cung cấp dữ liệu cho việc trainning và test model. Đặt câu hỏi hoặc định nghĩa vấn đề được mô tả ở đây trên Kaggle.</p>
<p>Kết thúc</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-titanic-data-science-solutions/" data-id="ck74jjgst00992mcpmksh21m5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-2-linear-regression-hoi-quy-tuyen-tinh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-2-linear-regression-hoi-quy-tuyen-tinh/" class="article-date">
  <time datetime="2018-12-03T03:05:36.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Machine-learning/">Machine learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-2-linear-regression-hoi-quy-tuyen-tinh/">2. Linear Regression - Hồi quy tuyến tính</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>TBD</p>
</blockquote>
<h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Chúng ta cùng nhau bắt đầu với mô hình đơn giản nhất (Linear Regression).</p>
<h2 id="Linear-Regression-Model"><a href="#Linear-Regression-Model" class="headerlink" title="Linear Regression Model"></a>Linear Regression Model</h2><h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Vậy là chúng ta đã kết thúc linear regression</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-2-linear-regression-hoi-quy-tuyen-tinh/" data-id="ck74jjgpm00202mcp29wcmugb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-phan-4-deep-learning-cho-chatbot-tao-generative-chatbot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-phan-4-deep-learning-cho-chatbot-tao-generative-chatbot/" class="article-date">
  <time datetime="2018-12-03T01:25:49.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Deep-learning/">Deep learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-phan-4-deep-learning-cho-chatbot-tao-generative-chatbot/">Phần 4: Deep Learning cho Chatbot - Tạo generative Chatbot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>TBD</p>
</blockquote>
<h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><h2 id="Tao-generative-Chatbot"><a href="#Tao-generative-Chatbot" class="headerlink" title="Tạo generative Chatbot"></a>Tạo generative Chatbot</h2><h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Đến đây nhiều bạn cho rằng là kết quả chẳng được như mong đợi. Có nhiều chatbot framework, thư viện khác để chúng ta tạo ra một chatbot có thể giải quyết được vấn đề của chúng ta, thông báo lịch làm việc, đặt vé máy bay, cái này còn chẳng báo nổi giờ, đã thế thời gian bỏ ra để train model là quá nhiều. Cũng đúng, nhưng với bản thân mình thì mình đã học được rất nhiều, mình phải mất rất nhiều thời gian để có thể sử dụng được tensorflow để implement model này, chưa kể vấn đề generate model, smart chatbot vẫn còn đang nghiên cứu. Có thể nó chẳng được ích lợi gì cho thực tế, nhưng hãy nhìn vào góc độ học tập thì cũng coi như một thành công. Trong bài tiếp theo chúng ta sẽ tìm hiểu cách sử dụng một số thư viện, framework chatbot để ứng dụng thực tế. Tạo một trợ lý riêng. Cám ơn các bạn đã theo dõi bài viết.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-phan-4-deep-learning-cho-chatbot-tao-generative-chatbot/" data-id="ck74jjgsf00862mcpq4d8yvrk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-phan-3-deep-learning-cho-chatbot-tao-mot-generative-chatbot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-phan-3-deep-learning-cho-chatbot-tao-mot-generative-chatbot/" class="article-date">
  <time datetime="2018-12-03T01:10:31.000Z" itemprop="datePublished">2018-12-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Deep-learning/">Deep learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-phan-3-deep-learning-cho-chatbot-tao-mot-generative-chatbot/">Phần 3: Deep Learning cho Chatbot - Thiết kế generative Chatbot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Ở bài trước chúng ta đã tạo ra một retrieval based Chatbot. Lúc đó mình còn phân vân liệu cái encoder-decoder, seq2seq translate này có phải là retrieval based model hay không. Vì mục đích của mình ban đầu là làm sao cho nó map đúng các câu hội thoại là được. Mình muốn nhắc lại cho các chưa xem các bài viết trước. Retrieval based sẽ đánh giá các câu trả lời có tiềm năng và chọn ra câu tốt nhất để trả lời, không từ mới, không câu mới. Generative model tự sinh ra câu trả lời dựa trên câu yêu cầu. Và mình cũng tìm kiếm các cách tạo ra một generative model nhưng đa phần các bài viết đều nói về mô hình encoder-decoder như mình làm. Cũng có thể gọi là generative vì các câu trả lời được sinh ra đúng theo nghĩa đen tuy rằng nó tối nghĩa. Có nghĩa là chúng ta đang đi đúng hướng. Dẫu chatbot được tạo nó chẳng thông minh tẹo nào, nhưng cũng đươc coi là generative model. Và nó có tệ thế nào đi chăng nữa thì ít nhất chúng ta cũng đã thử. Sự lựa chọn tồi tạo nên những câu chuyện đẹp.</p>
<h2 id="Chatbots-voi-Seq2Seq"><a href="#Chatbots-voi-Seq2Seq" class="headerlink" title="Chatbots với Seq2Seq"></a>Chatbots với Seq2Seq</h2><p>Khi Telegram released <a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">bot API</a>, cung cấp một cách dễ dàng cho các developers, để tạo ra bots bằng cách tương tác với  <a href="https://telegram.me/botfather" target="_blank" rel="noopener">Bot Father.</a> Ngay lập tức mọi người bắt đầu tạo ra các abstractions (thư viện) cho nodejs, ruby và python, để tạo bot. Chúng ta (Cộng đồng phần mềm tự do) đã tạo ra một nhóm cho việc tương tác với các bot chúng ta đã tạo được. Tôi đã tạo bằng nodejs có thể trả lời bất kỳ truy vấn để trong dấu nháy (dấu nháy ở đây chắc để đánh dấu cho câu cần truy vấn). Chương trình sử dụng linux utility <a href="https://en.wikipedia.org/wiki/Fortune_(Unix)" target="_blank" rel="noopener">fortune,</a> một pseudorandom message generator. Nó thật ngu ngốc. Nhưng rất vui khi nhìn thấy moi người sẵn sàng tương tác với một chương trình, cái mà đã được tạo ra. Một số người tạo ra Hodor bot. Bạn có thể hình dùng được cái mà nó sẽ làm. Sau khi tôi đã gặp các con bot khác nhau, <a href="http://www.mitsuku.com/" target="_blank" rel="noopener">Mitsuku</a> cái mà khá thông minh. Nó được viết bằng AIML (Artificial Intelligence Markup Language), một ngôn ngữ dạng XML cho phép lập trình viên viết các luật cho bot. Về cơ bản, bạn viết một PATTERN và một TEMPLATE, giống như khi bot nhận được câu khớp với pattern từ người dùng, nó sẽ trả lời với một templates. Chúng ta gọi loại model này là <strong>Rule based model</strong>. Mô hình dựa theo luật. Rule based model là cách dễ dàng cho bất kỳ ai có thể tạo ra được bot. Nhưng nó là vô cùng khó khăn khi tạo ra một bot có câu trả lời phức tạp. Pattern sẽ khớp với các kiểu đơn giản và kể từ đó AIML sẽ khó khăn khi chúng gặp phải những câu chưa được định nghĩa. Và nó cũng mất nhiều thời gian và công sức để viết các luật bằng tay. Nếu chúng ta có thể tạo ra một bot có thể học từ các cuộc hội thoại giữa con người. Đây là nơi mà Machine Learning có đất dụng võ. Chúng ta sẽ cho model tự học từ data, một model thông minh, Intelligent models có thể chia làm hai loại:</p>
<ol>
<li><strong>Retrieval-based</strong> models</li>
<li><strong>Generative</strong> models</li>
</ol>
<p>Retrieval-based model lấy một câu trả lời trong tập câu trả lời có sẵn. Nó không thể tạo ra bất kỳ câu thoại mới, vì thế chúng ta không cần lo lắng về ngữ pháp. Generate models thông minh hơn. Chúng tạo ra các câu trả lời, word by word. Các câu trả lời được tạo ra có thể có lỗi cú pháp. Những model này khó để train, chúng cũng cần phải học cấu trúc các câu một cách tự động. Tuy nhiên sau khi train, generative model sẽ cho kết quả tốt hơn retrieval-based model trong trường hợp phải xử lý câu mà nó chưa từng gặp và tạp ra một cuộc nói chuyện ấn tượng như con người (có lẽ là trẻ con). Đọc  <a href="http://www.wildml.com/2016/04/deep-learning-for-chatbots-part-1-introduction/" target="_blank" rel="noopener">Deep Learning For Chatbots</a> bởi Denny Britz, anh ta nói về length of conversations, open vs closed domain, các thử thách trong generative model như ngữ cảnh, tính cá nhân, hiểu được ý định của người dùng và làm thế nào để đánh giá được model. Chính là các bài viết trước mình đã dịch các bạn có thể tìm đọc lại.</p>
<h3 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h3><p>Sequence To Sequence model  giới thiệu trong  <a href="http://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a> sau đó trở thành model cho Dialogue System (Chatbot) và Machine Translation. Nó bao gồm hai RNNs (Recurrent Neural Network): Một Encoder và một Decoder. Encoder lấy một chuỗi (câu) làm input và xử lý các ký tự (các từ) trong mỗi lần. Nhiệm vụ của nó là chuyển một từ thành các vector có cùng kích cỡ, chỉ bao gồm các thông tin cần thiết và bỏ đi các thông tin cần thiết (có vẻ việc này được thực hiện tự động trong quá trình train). Bạn có thể xem flow. <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/encoder-decoder.png" alt> Hình ảnh được mượn từ_ <a href="https://github.com/farizrahman4u/seq2seq" target="_blank" rel="noopener">farizrahman4u/seq2seq</a>_ Mỗi hidden state (Một LSTM - một hình vuông trên ảnh đầu vào sẽ là một từ và một hidden state, đầu ra là hidden state và truyền qua LSTM cell tiếp theo) ảnh hưởng tới hidden state tiếp theo và hidden state cuối cùng có thể được nhìn thấy như là tổng kết của chuỗi. State này được gọi là context hoặc thought vector. Từ context (nghĩa là hidden state cuối cùng), the decoder sẽ tạo ra sequence (là câu trả lời được tạo ra), mỗi một từ một lần. Ở mỗi bước decoder sẽ bị ảnh hưởng bởi từ được tạo ra ở bước trước. <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/nct-seq2seq.png" alt> Hình ảnh được mượn từ_ <a href="http://www.wildml.com/2016/04/deep-learning-for-chatbots-part-1-introduction/" target="_blank" rel="noopener">Deep Learning for Chatbots : Part 1</a>_ Có một vài thử thách khi sử dụng model này. Cái mà phiền nhất là model không thể tự xử lý được chiều dài của câu văn. Nó là một điều phiền phức bởi hầu hết cho các ứng dụng seq2seq. Decoder dùng softmax cho toàn bộ từ vựng, lặp lại với mỗi từ của output. Điều này sẽ làm chậm quá trình train, mặc dù nếu phần cứng của bạn có khả năng xử lý được nó. Việc biểu diễn các từ là rất quan trọng. Bạn biểu diễn từ như thế nào? Sử dụng one-hot vector nghĩa là phải xử lý với vector lớn và one-hot vector không có ý nghĩa cho từ. Chúng ta sẽ phải đối mặt với các thử thách trên, từng cái một.</p>
<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>Trước train, chúng ta sẽ nhìn vào tập dữ liệu để chuyển chiều dài của các câu cho nó giống nhau bằng cách padding. Chúng ta sẽ sử dụng một vài ký tự đặc biệt để thêm vào câu.</p>
<ol>
<li><strong>EOS</strong>: End of sentence</li>
<li>*<em>PAD: *</em>Filler</li>
<li>*<em>GO: *</em>Start decoding</li>
<li>*<em>UNK: *</em>Từ không có trong từ điển</li>
</ol>
<p>Các cặp câu query-response như sau:</p>
<p>Q : How are you?<br>A : I am fine.</p>
<h3 id="Bucketing"><a href="#Bucketing" class="headerlink" title="Bucketing"></a>Bucketing</h3><p>Giới thiệu padding đã giải quyết được vấn đề chiều dài của câu. nhưng trường hợp câu quá dài. Nếu câu dài nhất trong dữ liệu là 100, chúng ta encoder tất cả các câu của chúng ta với chiều dài 100, trường hợp này không mất bất kỳ từ nào. Bây giờ, chuyện gì sẽ xảy ra với từ “How are you?” ? Chúng ta có 97 PAD trong encoderd. Điều này sẽ làm mờ đi thông tin thật của cả câu(“How are you”). Bucketing giải quyết được vấn đề này, bằng cách đặt các câu trong các bucket khác kích cỡ. Cân nhắc danh sách sau: [(5, 10), (10, 15), (20, 25), (40, 50)]. Nếu chiều dài câu query là 4 và câu response là 4 chúng ta sẽ đặt vào bucket (5, 10). Query sẽ padded tới 5 ký từ và kết quả là 10. Trong khi run model (khi train và dự đoán), chúng ta sẽ sử dụng một model khác cho mỗi bucket, tương thích với chiều dài của query và response. Tất cả các model sẽ cùng parameter và ví thể function sẽ hoàn toàn giống nhau Nếu chúng ta sử dụng bucket (5, 10). các câu của chúng ta sẽ được encoded như sau:</p>
<p>Q : [ PAD, “?”, “you”, “are”, “How” ]<br>A : [ GO, “I”, “am”, “fine”, “.”, EOS, PAD, PAD, PAD, PAD ]</p>
<h3 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h3><p>Word Embedding là kĩ thuật cho việc biểu diễn các từ một không gian vector có số chiều thấp. Mỗi từ có thể được nhìn thấy như một điểm trong không gian này, biểu diễn bởi chiều dài cố định. Ngữ nghĩa liên quan giữa các từ cũng được lưu giữ bởi kĩ thuật này. Word vectors có những thuộc tính thú vị:</p>
<p>paris – france + poland = warsaw</p>
<p>khoảng cách giữa paris - france = warsaw - poland <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/word-embedding.png" alt> Hình ảnh được mượn từ <em><a href="https://blog.kaggle.com/2016/05/18/home-depot-product-search-relevance-winners-interview-1st-place-alex-andreas-nurlan/" target="_blank" rel="noopener">Home Depot Product Search Relevance, Winners’ Interview</a></em> Word embedding là thường là lớp đầu tiên của mạng: Embedding layer map 1 từ trong từ điển tới một vector cho sẵn kích thước. Trong seq2seq model trọng số của embedding layer được train cùng với các tham số khác của model. Theo chân <a href="http://sebastianruder.com/word-embeddings-1/" target="_blank" rel="noopener">tutorial</a> này bởi Sebastian Ruder để học về các model kahsc sử dụng word embedding và tầm quan trọng của nó trong NLP. (ok mình thì dùng một word embedding đã được trên từ trước và mình không thay đổi nó, mình không rõ như bên trên có cải thiện nhiều không, chẳng còn cách nào khác chỉ có thể thử thôi :D)</p>
<h3 id="Papers-on-Sequence-to-Sequence"><a href="#Papers-on-Sequence-to-Sequence" class="headerlink" title="Papers on Sequence to Sequence"></a>Papers on Sequence to Sequence</h3><ol>
<li><p><a href="http://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></p>
</li>
<li><p><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></p>
</li>
<li><p><a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Neural Machine Translation by Jointly Learning to Align and Translate</a></p>
</li>
<li><p><a href="http://arxiv.org/abs/1506.05869" target="_blank" rel="noopener">A Neural Conversational Model</a></p>
<p>Phần sau của bài viết này nói đến Attention Mechanism. Mình có xem phần lý thuyết của Attention rồi nhưng mình sẽ học thêm cho vững và trình bày trong một bài khác.</p>
</li>
</ol>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Bài viết được dịch từ <a href="http://complx.me/2016-06-28-easy-seq2seq/" target="_blank" rel="noopener">http://complx.me/2016-06-28-easy-seq2seq/</a> Có rất nhiều thứ cần phải làm ở đây. Chúng ta cứ đi thẳng, đến ngã rẽ tự bản thân sẽ biết đi đường nào. Hẹn gặp lại các bạn trong bài viết tiếp theo. Mình sẽ trình bày về cách tạo Chatbot của mình. Cám ơn các bạn!.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-phan-3-deep-learning-cho-chatbot-tao-mot-generative-chatbot/" data-id="ck74jjgup00d92mcpf8am2p0q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-blog-phan-2-deep-learning-cho-chatbot-tao-retrieval-based-model-voi-tensorflow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/blog-phan-2-deep-learning-cho-chatbot-tao-retrieval-based-model-voi-tensorflow/" class="article-date">
  <time datetime="2018-12-02T02:19:39.000Z" itemprop="datePublished">2018-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Deep-learning/">Deep learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/blog-phan-2-deep-learning-cho-chatbot-tao-retrieval-based-model-voi-tensorflow/">Phần 2: Deep Learning cho Chatbot - Tạo Retrieval-Based Model với Tensorflow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>TBD</p>
</blockquote>
<h2 id="Mo-dau"><a href="#Mo-dau" class="headerlink" title="Mở đầu"></a>Mở đầu</h2><p>Đây là bài dịch tiếp theo. Chúng ta sẽ cùng tạo một retrieval-based Model Chatbot.</p>
<h2 id="Noi-dung"><a href="#Noi-dung" class="headerlink" title="Nội dung"></a>Nội dung</h2><p>Trong bài này chúng ta sẽ implement một retrieval-based bot. Retrieval-based model có một kho định nghĩa trước các câu trả lời chúng có thể sử dụng, không giống như generative models cái mà có thể generate câu trả lời chúng không bao giờ nhìn thấy trước đây. Rõ hơn, từ một câu đầu vào tới retrieval-based model là một context c sẽ chọn ra một câu trả lời response r có khả năng nhất. Ouputs của model là câu trả lời tốt nhất. Để tìm ra câu trả lời tốt nhất bạn cần phải tính toán điểm cho tất cả các câu trả lời và chọn ra một với số điểm cao nhất. Nhưng tại sao chúng ta lại tạo một retrieval-based model nếu chúng ta có thể tạo một generative model? Generative models dường như linh hoạt hơn bnowir vì chúng không cần kho câu trả lời định nghĩa trước, phải không các bạn? Vấn đề là generative models không hoạt động tốt trong thực tế. Ít nhất là cho tới bây giờ. Bởi vì chúng ta có quá nhiều tự do cho việc chúng có thể trả lời như thế nào, generative models có thể tạo ra các lỗi cú pháp, không có nghĩa, không nhất quán. Chúng cũng cần một số lượng dữ liệu training lớn và khó để tối ưu. Đa số hệ thống ngày nay là retrieval-based, hoặc kết hợp giữa retrieval-based và generative. Google’s Smart Reply là một ví dụ. Generative models đang là lĩnh vực active trong nghiên cứu. Nhưng chúng ta không quan trọng, nếu chúng ta tạo một chatbot ngày nay, lựa chọn tốt nhất là tạo một retrieval-based model</p>
<h3 id="The-Ubuntu-Dialog-Corpus"><a href="#The-Ubuntu-Dialog-Corpus" class="headerlink" title="The Ubuntu Dialog Corpus"></a>The Ubuntu Dialog Corpus</h3><p>Trong bài viết này chúng ta sẽ sử dụng Ubuntu Dialog Corpus (<a href="http://arxiv.org/abs/1506.08909" target="_blank" rel="noopener">paper</a>, <a href="https://github.com/rkadlec/ubuntu-ranking-dataset-creator" target="_blank" rel="noopener">github</a>). Ubuntu Dialog Corpus (UDC) là một trong những tập dữ liệu hội thoại lớn nhất được public. Nó được dựa trên các lưu trữ chat từ các kênh Ubuntu trên <strong>public</strong> <a href="https://vi.wikipedia.org/wiki/IRC" target="_blank" rel="noopener"><strong>IRC</strong></a> <strong>network</strong> (ok là một dạng liên lạc cấp tốc qua mạng gì đó).  <a href="http://arxiv.org/abs/1506.08909" target="_blank" rel="noopener">Paper </a>này sẽ đi vào chi tiết chính xác dữ liệu được tạo như thế nào, vì thế tôi không lặp lại nó ở đây. Tuy nhiên, việc hiểu được dữ liệu là quan trọng khi chúng ta làm việc với chúng, vì thế để tôi giải thích nó trước. Tập dữ liệu training bao gồm 1000000 mẫu, với 50% positive (label 1), 50% negative (label 0). Mỗi vĩ dụ bao gồm <strong>context</strong>, là điểm bắt đầu hội thoại, và một <strong>utterance</strong>, một câu phản hồi cho context trên. Positive với label 1 nghĩa là câu phản hồi là thực sự cho context đó, và negative label 0 nghĩa là không phải, Chọn ngẫu nhiên một số mẫu, đây là một vài mẫu dữ liệu. <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/ubuntu-dialog-corpus.png" alt> Các dữ liệu được generation script đã được tiền xử lý cho chúng ta (cái này mình không biết là bản thân dữ liệu UDC được tiền xử lý hay là script của bài viết này tiền xử lý, mình sẽ xem thử và trình bày rõ cho các bạn) - Tiền xử lý ở đây là  <a href="http://www.nltk.org/api/nltk.tokenize.html#module-nltk.tokenize" target="_blank" rel="noopener">tokenized</a>, <a href="http://www.nltk.org/api/nltk.stem.html#module-nltk.stem.snowball" target="_blank" rel="noopener">stemmed</a>, and <a href="http://www.nltk.org/api/nltk.stem.html#module-nltk.stem.wordnet" target="_blank" rel="noopener">lemmatized</a> sử dụng <a href="http://www.nltk.org/" target="_blank" rel="noopener">NLTK tool</a>. Script này cũng đã thay thế các entities giống như tên, địa điểm, tổ chức, các url, các đường dẫn hệ thống bằng các ký tự đặc biệt. Việc tiền xử lý này không phải là phải làm, nhưng nó cũng sẽ giúp tăng hiệu quả một vài phần trăm. Trung bình context có 86 từ và utterance có 17 từ. Chúng ta có thể em chi tiết <a href="https://github.com/dennybritz/chatbot-retrieval/blob/master/notebooks/Data%20Exploration.ipynb" target="_blank" rel="noopener">jupyter notebook.</a> Tập dữ liệu còn bao gồm cả tập test sets và validation sets (Ngắn gọn thì đây là 2 tập không để đem đi train mà là tập chưa nhìn thấy để đánh giá model). Định dạng của chúng khác với tập dữ liệu train. Mỗi dữ liệu trong test/validation bao gồm một context, một utterance đúng và 9 utterance sai được gọi là *<em>distractors. *</em>Mục đích của model là gán điểm cao nhất cho đúng utterance, và thấp hơn cho các utterances sai (ok). <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/urc-test-validation-set.png" alt> Có rất nhiều cách để đánh giá model. Cách thường sử dụng là recall@k. *<em>Recall@k *</em>nghĩa là model sẽ chọn ra k câu phản hồi tốt nhất trong 10 câu trả lời có thể (1 đúng và 10 sai). Nếu cái đúng nằm trong những cái mà chúng ta đã đánh dấu thì được coi là đúng (để dễ hiểu chọn k=3 ta chọn ra 3 câu phản hồi tốt nhất nếu trong 3 câu đó mà chứa câu đúng thì được coi là đúng). Vì thế k lớn hơn thì là dễ hơn. Nếu chúng ta set k=10 chúng ta sẽ có recall là 100% bởi vì chúng ta chỉ có 10 câu trả lời. Nếu chúng ta chọn k=1 thì model chỉ có một cơ hội để chọn ra câu trả lời đúng. Ở thời điểm này có lẽ bạn đang tự hỏi là 9 distractors(câu sai) được chọn như thế nào. Trong tập dữ liệu 9 câu sai được lấy ngẫu nhiên. Tuy nhiên trong thực tế bạn có cả triệu khả năng để chọn và bạn không biết được cái nào là đúng. Bạn không thể đánh giá cả triệu câu trả lời để lấy ra một cái có số điểm cao nhất - điều này là quá tốn kém (thời gian đôi khi hệ thống cần trả lời nhanh, ví dụ chatbot gửi câu yêu cầu là cần phản hồi nhanh không thể ngồi đợi đánh giá tất cả rồi chọn câu tốt nhất được, đến đây ta có thể mong ngóng bài viết sẽ đưa ra được mô hình tốt chứ không đơn giản như vậy). <a href="http://arxiv.org/abs/1606.04870" target="_blank" rel="noopener">Google Smart Reply </a>sử dụng kĩ thuật chia nhỏ các câu trả lời có thể chọn, hoặc nếu bạn chỉ có vài trăm câu trả lời thích hợp trong tất cả bạn có thể đánh giá tất. (Brute force được dùng ở mọi nơi phải không các bạn :D).</p>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>Trước khi bắt đầu với mạng neural chúng ta hãy thử tạo ra một vài thứ đơn giản để giúp chúng ta có thể hiểu được hiệu quả chúng ta mong muốn. Chúng ta sẽ sử dụng function dưỡi đây để đánh giá recall@k: (Các mã code ở đây mình sẽ copy nguyên si để ta tôn trọng tác giả, mình sẽ implement một cái của riêng mình ở phía cuối cùng chúng ta sẽ cùng làm từ đầu).</p>
<p>def evaluate_recall(y, y_test, k=1):<br>    num_examples = float(len(y))<br>    num_correct = 0<br>    for predictions, label in zip(y, y_test):<br>        if label in predictions[:k]:
            num_correct += 1<br>    return num_correct/num_examples</p>
<p>Ở đây, y là tập các dự đoán của ta đã được sắp xếp theo điểm giảm dần, và y_test là các nhãn thực sự. Ví dụ y = [0,3,1,2,5,6,4,7,8,9] nghĩa là utteramce số 0 nhận điểm cao nhất, và 9 thấp nhất. Nhớ rằng chúng ta có 10 utterance, với mỗi test example và cái đầu tiên luôn là cái đúng, bởi vì trong dữ liệu test ở trên cột đúng đầu tiên, rồi đến 9 cái sai theo sau. Theo trực giác, nếu chọn một cách ngẫu nhiên ta có kết quả recall@1 là 10%, recall@2 là 20%, …Hãy xem trường hợp dưới đây.</p>
<p># Random Predictor<br>def predict_random(context, utterances):<br>    return np.random.choice(len(utterances), 10, replace=False)<br># Evaluate Random predictor<br>y_random = [predict_random(test_df.Context[x], test_df.iloc[x,1:].values) for x in range(len(test_df))]<br>y_test = np.zeros(len(y_random))<br>for n in [1, 2, 5, 10]:
    print(“Recall @ ({}, 10): {:g}”.format(n, evaluate_recall(y_random, y_test, n)))</p>
<p>Kết quả khi lấy ngẫu nhiên.</p>
<p><code>Recall @ (1, 10): 0.0937632</code></p>
<p><code>Recall @ (2, 10): 0.194503</code></p>
<p><code>Recall @ (5, 10): 0.49297</code></p>
<p><code>Recall @ (10, 10): 1</code></p>
<p>Great, trông có vẻ đã hoạt động. Đúng vậy nếu chúng ta chỉ lấy ngẫu nhiên. Một kiểu khác chúng ta sẽ thảo luận trong paper chính thức (hay research paper là các bài nghiên cứu) là tf-idf predictor. <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank" rel="noopener">tf-idf</a> là viết tắt của “term frequency inverse document”  tần số và các phép đo độ quan trọng của một từ trong một tài liệu quan hệ với cả corpus. Chúng ta không đi vào chi tiết (bạn có thể tìm thấy nhiều bài hướng dẫn về tf-idf trên mạng), các tài liệu có nội dung giống nhau sẽ có các một vector tf-idf tương tự (ok có thể sẽ có tutorial chống đạo văn từ cái này nhỉ). Rõ ràng nếu nội dung có các từ tương tự nhau chúng nhiều khả năng là cặp đúng. Ít nhất thì nó còn hơn là chọn ngẫu nhiên. Nhiều thư viện như scikit-learn có sẵn tf-idf functions, vì thế nên nó dễ dàng sử dụng. Chúng ta cùng tạo ra một tf-idf predictor và xem nó hoạt động tốt không.</p>
<p>class TFIDFPredictor:<br>    def __init__(self):<br>        self.vectorizer = TfidfVectorizer()</p>
<pre><code>def train(self, data):
    self.vectorizer.fit(np.append(data.Context.values,data.Utterance.values))

def predict(self, context, utterances):
    # Convert context and utterances into tfidf vector
    vector_context = self.vectorizer.transform(\[context\])
    vector_doc = self.vectorizer.transform(utterances)
    # The dot product measures the similarity of the resulting vectors
    result = np.dot(vector\_doc, vector\_context.T).todense()
    result = np.asarray(result).flatten()
    # Sort by top results and return the indices in descending order
    return np.argsort(result, axis=0)\[::-1\]</code></pre><p># Evaluate TFIDF predictor<br>pred = TFIDFPredictor()<br>pred.train(train_df)<br>y = [pred.predict(test_df.Context[x], test_df.iloc[x,1:].values) for x in range(len(test_df))]<br>for n in [1, 2, 5, 10]:
    print(“Recall @ ({}, 10): {:g}”.format(n, evaluate_recall(y, y_test, n)))</p>
<p>Kết quả</p>
<p><code>Recall @ (1, 10): 0.495032</code></p>
<p><code>Recall @ (2, 10): 0.596882</code></p>
<p><code>Recall @ (5, 10): 0.766121</code></p>
<p><code>Recall @ (10, 10): 1</code></p>
<p>Chúng ta có thể thấy rằng tf-idf model tốt hơn đáng kể so với chọn ngẫu nhiên. Nhưng nó chưa được hoàn hảo. Giả định rằng chúng ta đã làm không được tốt. Đầu tiên một câu trả lời không cần thiết phải giống với câu context.</p>
<p>Thứ hai, tf-idf bỏ qua thứ tự của từ, cái có thể là một tín hiệu quan trọng. Với một Neural Network model chúng ta có thể làm tốt hơn.</p>
<h3 id="Dual-Encoder-LSTM"><a href="#Dual-Encoder-LSTM" class="headerlink" title="Dual Encoder LSTM"></a>Dual Encoder LSTM</h3><p>Deep learning model mà chúng ta sẽ tạo ra trong bài viết này được gọi là Dual Encoder LSTM network. Đây chỉ là một trong nhiều cách chúng ta có thể áp dụng cho vấn đề này và nó không phải là cái tốt nhất. Bạn có thể thử với các loại kiến trúc Deep learning khác cái chưa được thử - nó là một lĩnh vực đang được nghiên cứu. Lấy ví dụ,  <a href="https://www.tensorflow.org/versions/r0.9/tutorials/seq2seq/index.html" target="_blank" rel="noopener">seq2seq model</a> thường xuyên được sử dụng trong Machine Translation (ở bài sau mình sẽ trình bày mô hình này cũng như chatbot mình làm được, mình cứ nghĩ cái mình làm được là generative model, nhưng có vẻ nó chỉ là retieval model thôi. Các bạn có thể trả lời câu hỏi này giúp mình nhé. Cám ơn các bạn) cái mà sẽ hoạt động tốt cho nhiệm vụ này. Lý do chúng ta chọn Dual Encoder là bởi vì nó <a href="http://arxiv.org/abs/1510.03753" target="_blank" rel="noopener">được báo cáo</a> đạt được hiệu quả tốt trên tập dữ liệu này. Điều này có nghĩa là chúng ta biết là cái chúng ta mong đợi có thể chắc chắn model của chúng ta sẽ hoạt động tốt. Việc áp dụng các model khác cho vấn đề này sẽ là một dự án thú vị. The Dual Encoder LSTM chúng ta sẽ tạo giống như (<a href="http://arxiv.org/abs/1506.08909" target="_blank" rel="noopener">paper</a>): <img src="http://35.196.17.90/blog/wp-content/uploads/2018/12/dual-encoder-lstm.png" alt> Nó hoạt đống giống như sau:</p>
<ol>
<li>Tất cả các context và response được chia thành các từ và được chuyển thành dạng vector với embedded (đơn giản nó là một vector được xây dựng sẵn ví dụ từ “father” = [0 2.1 -3.4 …. 2.5] mình ví dụ như vậy). Word Embeddings được khởi tạo từ Stanford’s <a href="http://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">GloVe</a> vectors và được fine-tuned trong suốt quá trình training (Side note: Điều này là không bắt buộc và không được thể hiện trong bức tranh. Tôi tìm thấy các word embeddings với GloVe không làm tạo ra sự khác biệt cho độ hiệu quả của model). (ok vậy cũng không quan trọng lắm việc chất lượng word embedded và việc fine-turned được nói ở trên liệu có phải trong quá trình train mình sẽ sửa lại cái ma trận word embbeded được cung cấp sẵn không, model của mình làm thì mình không thay đổi ma trận này).</li>
<li>Tất cả các embedded context và response được cho vào cùng một Recurrent Neural Network word-by-word. Chúng ta có thể chọn vectors lớn hơn, ở đây chúng ta chọn 256 chiều.(ok mình hiểu một từ được biểu diễn 256 con số ví dụ từ “father” bên trên sẽ chuyển thành ma trận 256 cột).</li>
<li>Chúng ta sẽ nhân c với một ma trận M để dự đoán kết quả r’. Nếu c là 1x256 chiều, thì M là 256x256 và kết quả sẽ được là vector 1x256, cái chúng ta có thể tạo ra như là generated response. Ma trận M này sẽ được học trong suốt quá trình train.(ok ma trận này được khởi tạo ngẫu nhiên và trong quá trình train ma trận này sẽ thay đổi trọng số để có thể từ đầu vào sẽ tạo ra đúng đầu ra).</li>
<li>Chúng ta sẽ đo sự giống nhau của kết quả r’ và kết quả thực sự bằng cách dot product(nhân ma trận) giữa hai vector. Một dot product lớn nghĩa là hai vectors giống nhau.(ok 1x256 nhân 256x1 sẽ được 1x1 một số nhưng mình vẫn chưa hiểu sao số này lớn 2 vector lại giống nhau ví dụ 0.1x0.5 &gt; 0.1x0.1 nhưng 0.1 và 0.1 giống nhau hơn). Sau đó chúng ta sẽ áp dụng hàm sigmoid function để chuyển kết quả này thành xác suất. Bước 3 và 4 đã bao gồm trong hình.</li>
</ol>
<p>Để train model, chúng ta cần một loss(cost) function. Chúng ta sẽ sử dụng binary cross-entropy loss là thường sử dụng cho classification problems. Chúng ta sẽ gọi true label cho cặp context-response y. 1 đúng 0 sai. Lấy predicted xác suất từ 4. Sau đó dùng cross entropy loss được tính toán L= −y * ln(y’) − (1 − y) * ln(1−y’). (ok các bạn không cần quá lo lắng chúng ta có sẵn cross entropy loss trong các deep learning framework như tensorflow, pytorch, … Nếu các bạn vẫn cảm thấy khó chịu thì chúng ta sẽ học machine learning căn bản và deep learning, thời gian sẽ trả lời, …). Chúng ta sẽ sử dụng cả numpy, pandas, tensorflow và tf learn(tổng hợp của các hàm tiện ích bậc cao cho tensorflow cái này mình không biết mình dùng tensorflow low level và thấy thuận tiện còn muốn high level thì mình dùng keras món tf learn này mình chưa thử).</p>
<h3 id="Tien-xu-ly"><a href="#Tien-xu-ly" class="headerlink" title="Tiền xử lý"></a>Tiền xử lý</h3><p><a href="https://github.com/rkadlec/ubuntu-ranking-dataset-creator" target="_blank" rel="noopener">Dataset</a> chính thức có định dạng CSV. Chúng ta có thể làm việc trực tiếp với CSV nhưng tốt hơn để thuận tiện cho việc chuyển dữ liệu sang dạng tensorflow. (Quick side note: tf.SequenceExample nhưng nó dường như không được hỗ trợ bởi tf.learn nữa. ok bản thân mình không hiểu mấy cái này). Lợi ích chính của định dạng này là cho phép chúng ta load tensor trực tiếp từ input files và để tensorflow xử lý tất cả việc shuffling, batching, queuing của inputs (ok nghe hay nhỉ). Một phần của việc tiền xử lý là chúng ta cần tạo ra vocabulary. Nghĩa là chúng ta sẽ map mỗi từ thành một con số, ví dụ “cat” thành 2631. TFRecord files sẽ chuyển lưu trữ thành các con số thay thế các chuỗi. Chúng ta sẽ lưu vocabulary vì thế chúng ta có thể map các con số trở lại thành các từ sau này. Mỗi một example sẽ bao gồm các trường sau: context: Một sequence of word ids được biểu diễn context text ví dụ [231, 2190, 737, 0, 912] biểu diễn cho “tf learn làm hết rồi”. context_len: Chiều dài của context là 5 cho ví dụ bên trên utterance: Một sequence of word ids biểu diễn cho utterance (response) utterance_len: Chiều dài utterance label: Chỉ cho training data là 0 hoặc 1 distractor_[N]: Chỉ cho test/validation data. N từ 0 đến 9. Một sequence of word ids trình bày distractor utterance distractor_[N]_len: Chỉ cho test/validation data, chiều dài cho cái bên trên The preprocessing đã xong với  <a href="https://github.com/dennybritz/chatbot-retrieval/blob/master/scripts/prepare_data.py" target="_blank" rel="noopener"><code>prepare_data.py.</code></a>Python script, cái sẽ tạo ra 3 files: <code>train.tfrecords</code>, <code>validation.tfrecords</code> and <code>test.tfrecords</code>. Bạn có thể tự chạy script hoặc tải các data file từ <a href="https://drive.google.com/open?id=0B_bZck-ksdkpVEtVc1R6Y01HMWM" target="_blank" rel="noopener">đây </a>.</p>
<h3 id="Tao-mot-input-function"><a href="#Tao-mot-input-function" class="headerlink" title="Tạo một input function"></a>Tạo một input function</h3><p>Để sử dụng Tensorflow’s built-in hỗ trợ cho việc training và đánh giá chúng ta cần tạo ra các input function - một function sẽ trả về tập dữ liệu cho chúng ta. Trong thực tế, bởi vì dữ liệu training và dữ liệu test khác nhau về định dạng, chúng ta cần phải có các input functions khác nhau cho chúng. Input function nên trả về batch of features và nhãn (nếu có sẵn). Đây là một vài dòng mã giả:</p>
<p>def input_fn():</p>
<h1 id="TODO-Load-and-preprocess-data-here"><a href="#TODO-Load-and-preprocess-data-here" class="headerlink" title="TODO Load and preprocess data here"></a>TODO Load and preprocess data here</h1><p>  return batched_features, labels</p>
<p>Bởi vì chúng ta cần input function khác nhau trong suốt quá trình training và đánh giá và bởi vì chúng ta ghét việc phải lặp lại code, chúng ta tạo ra một wrapper gọi là create_input_fn cái mà tạo ra một input function cho các mode thích hợp. Nó thêm một vài tham số khác. Đây là định nghĩa chúng ta sử dụng:</p>
<p>def create_input_fn(mode, input_files, batch_size, num_epochs=None):<br>  def input_fn():</p>
<pre><code># TODO Load and preprocess data here
return batched_features, labels</code></pre><p>  return input_fn</p>
<p>Đầy đủ code chúng ta có thể tìm thấy trong <code>[udc_inputs.py](https://github.com/dennybritz/chatbot-retrieval/blob/master/udc_inputs.py).</code>Một high level function làm được những thứ sau:</p>
<ol>
<li>Tạo một feature definition để mô tả các trường của chúng ta.</li>
<li>Đọc vào các dòng từ input_files với tf.TFRecordReader</li>
<li>Parse các records thành các feature definition (có lẽ là thành một example với định dạng như phần tiền xử lý mình nói ở trên)</li>
<li>Trích xuất training labels</li>
<li>Tạo batch nhiều mẫu và training labels</li>
<li>Trả về batch và training labels</li>
</ol>
<p>Định nghĩa cách đánh giá model. Chúng ta đã nhắc đến việc chúng ta muốn sử dụng recall@k metric để đánh giá model của chúng ta. Thật may mắn Tensorflow đã có sẵn với nhiều evaluation metrics cho chúng ta có thể sử dụng bao gồm cả including recall@k. Để sử dụng metrics này chúng ta cần tạo một từ điển maps từ tên số liệu tới một hàm nhận predictions (cái chúng ta dự đoán) và labels(kết quả thật sự) làm tham số.</p>
<p>def create_evaluation_metrics():<br>  eval_metrics = {}<br>  for k in [1, 2, 5, 10]:
    eval_metrics[“recall_at_%d” % k] = functools.partial(<br>        tf.contrib.metrics.streaming_sparse_recall_at_k,<br>        k=k)<br>  return eval_metrics</p>
<p>Bên trên chúng ta sử dụng  <code>[functools.partial](https://docs.python.org/2/library/functools.html#functools.partial)</code> để chuyển functions nhận 3 tham số tới một cái functions nhận hai tham số (mình không thực sự hiểu lắm). Đừng để tên streaming_sparse_recall_at_k khiến bạn nhầm lẫn. Streaming chỉ có nghĩa là hàm tích lũy thông qua các batches và làm rời rạc để cùng định dạng với labels của chúng ta (kiểu cộng dồn qua các batch và chuyển về dạng 0 1 với định dạng labels). Điều này mang lại một điểm quan trọng: Định dạng chính xác cho predictions là gì? Trong suốt quá trình training chúng ta dự đoán xác suất của các example là đúng. Nhưng trong suốt quá trình đánh giá mục đích của chúng ta là tính điểm cho utterance và 9 distractors và chọn ra cái tốt nhất. Bài viết chưa hoàn thành, mình sẽ cập nhật sớm nhất có thể, …</p>
<h3 id="Ket-luan"><a href="#Ket-luan" class="headerlink" title="Kết luận"></a>Kết luận</h3><p>Trong bài viết này chúng ta đã implemented một retrieval-based neural network model cái có thể assign score tới câu trả lời tiềm năng với một context cho trước. Vẫn có nhiều điểm để cải thiện như thử các neural networks khác làm tốt hơn nhiệm vụ này hơn là Dual LSTM encoder. Cũng có nhiều hyperparameter optimization hoặc cải thiện quá trình tiền xử lý. <strong><a href="https://github.com/dennybritz/chatbot-retrieval/" target="_blank" rel="noopener">The Code and data for this tutorial is on Github, so check it out.</a></strong></p>
<h2 id="Ket-thuc"><a href="#Ket-thuc" class="headerlink" title="Kết thúc"></a>Kết thúc</h2><p>Như vậy là mình đã dịch xong <a href="http://www.wildml.com/2016/07/deep-learning-for-chatbots-2-retrieval-based-model-tensorflow/" target="_blank" rel="noopener">http://www.wildml.com/2016/07/deep-learning-for-chatbots-2-retrieval-based-model-tensorflow/</a> Đây là một bài hướng dẫn hay phải không các bạn. Còn một số chỗ mình chưa hiểu, và mình cũng chưa tự làm lại thì chưa thể nói là của mình được. Tóm lại chúng ta sử dụng recall@k để đánh giá, sử dụng Dual LSTM encoder để train, if-idf để biết được độ giống nhau với tham vọng làm được một hệ thống chống đạo văn, Ngoài keras còn có một thứ tên là tf-learn nữa cần phải đọc qua, và cái chatbot mình đang build dùng seq2seq machine translation model thì có vẻ là một dạng retrieval based model chứ không phải generative models. Mình mong bài hướng dẫn cho các bạn và có thể góp ý các phần bình luận trong đóng mở ngoặc tròn mà mình còn chưa hiểu. Trong bài tiếp theo mình sẽ hướng dẫn tiếp tạo chatbot với mô hình seq2seq. Cám ơn các bạn</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://taminhluan.github.io/blog/blog-phan-2-deep-learning-cho-chatbot-tao-retrieval-based-model-voi-tensorflow/" data-id="ck74jjgv700du2mcp1oov7454" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Programming/">Android Programming</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Programming/Note/">Note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Assembly/">Assembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Code-Viblo/">Code Viblo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Codesignal/">Codesignal</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-learning/">Deep learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIS/">GIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linh-tinh/">Linh tinh</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lap-trinh/">Lập trình</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-learning/">Machine learning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Programming/">Network Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Note/">Note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OWASP-Testing-Guide/">OWASP Testing Guide</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Phim/">Phim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Pre-Calculus/">Pre Calculus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Social-engineering/">Social engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/System-Programming/">System Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Text-to-speech/">Text to speech</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Text-to-speech/Tool/">Tool</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Toan-hoc/">Toán học</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tri-tue-nhan-tao/">Trí tuệ nhân tạo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Uncategorized/">Uncategorized</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unit-Testing/">Unit Testing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Visualisation/">Visualisation</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ctf/">ctf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hacker/">hacker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vnspoj/">vnspoj</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/wordpress/">wordpress</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Do-an/">Đồ án</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASP-net-MVC/">ASP.net MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Programming/">Android Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Asp-net/">Asp.net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assembly/">Assembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Basic-Access-Authentication/">Basic Access Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/">Blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Book/">Book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code/">Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Course/">Course</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Digest-Access-Authentication/">Digest Access Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Du-doan-gia-vang/">Dự đoán giá vàng</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ethical-Hacking/">Ethical Hacking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flask/">Flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIS/">GIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html-css-javascript/">Html, css, javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-System-Programming/">Linux, System Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Note/">Note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OWASP-Testing-Guide/">OWASP Testing Guide</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Php/">Php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Codesignal/">Python, Codesignal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quan-ly-diem/">Quản lý điểm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RFC-2069/">RFC 2069</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RFC-2617/">RFC 2617</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SJF/">SJF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Social-engineering/">Social engineering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sql-server/">Sql server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System-Programming/">System Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Text-to-speech/">Text to speech</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Todos/">Todos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tinh-toan-mem/">Tính toán mềm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VRML/">VRML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WPF/">WPF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows-Form/">Windows Form</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Winform/">Winform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Winforms/">Winforms</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Wordpress/">Wordpress</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fuzzy-computing/">fuzzy computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/import-csv/">import csv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/migrate/">migrate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordpress/">wordpress</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASP-net-MVC/" style="font-size: 10px;">ASP.net MVC</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Android-Programming/" style="font-size: 10px;">Android Programming</a> <a href="/tags/Angular/" style="font-size: 10px;">Angular</a> <a href="/tags/Asp-net/" style="font-size: 10px;">Asp.net</a> <a href="/tags/Assembly/" style="font-size: 14px;">Assembly</a> <a href="/tags/Basic-Access-Authentication/" style="font-size: 10px;">Basic Access Authentication</a> <a href="/tags/Blog/" style="font-size: 10px;">Blog</a> <a href="/tags/Book/" style="font-size: 10px;">Book</a> <a href="/tags/C/" style="font-size: 20px;">C#</a> <a href="/tags/Code/" style="font-size: 14px;">Code</a> <a href="/tags/Course/" style="font-size: 10px;">Course</a> <a href="/tags/Digest-Access-Authentication/" style="font-size: 10px;">Digest Access Authentication</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Du-doan-gia-vang/" style="font-size: 10px;">Dự đoán giá vàng</a> <a href="/tags/Ethical-Hacking/" style="font-size: 10px;">Ethical Hacking</a> <a href="/tags/Flask/" style="font-size: 10px;">Flask</a> <a href="/tags/GIS/" style="font-size: 10px;">GIS</a> <a href="/tags/Html-css-javascript/" style="font-size: 10px;">Html, css, javascript</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Linux-System-Programming/" style="font-size: 10px;">Linux, System Programming</a> <a href="/tags/Note/" style="font-size: 16px;">Note</a> <a href="/tags/OWASP-Testing-Guide/" style="font-size: 12px;">OWASP Testing Guide</a> <a href="/tags/Php/" style="font-size: 16px;">Php</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Python-Codesignal/" style="font-size: 10px;">Python, Codesignal</a> <a href="/tags/Quan-ly-diem/" style="font-size: 10px;">Quản lý điểm</a> <a href="/tags/RFC-2069/" style="font-size: 10px;">RFC 2069</a> <a href="/tags/RFC-2617/" style="font-size: 10px;">RFC 2617</a> <a href="/tags/SJF/" style="font-size: 10px;">SJF</a> <a href="/tags/Social-engineering/" style="font-size: 14px;">Social engineering</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/Sql-server/" style="font-size: 10px;">Sql server</a> <a href="/tags/System-Programming/" style="font-size: 14px;">System Programming</a> <a href="/tags/Text-to-speech/" style="font-size: 10px;">Text to speech</a> <a href="/tags/Todos/" style="font-size: 10px;">Todos</a> <a href="/tags/Tool/" style="font-size: 10px;">Tool</a> <a href="/tags/Tinh-toan-mem/" style="font-size: 10px;">Tính toán mềm</a> <a href="/tags/VRML/" style="font-size: 12px;">VRML</a> <a href="/tags/WPF/" style="font-size: 10px;">WPF</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/Windows-Form/" style="font-size: 10px;">Windows Form</a> <a href="/tags/Winform/" style="font-size: 10px;">Winform</a> <a href="/tags/Winforms/" style="font-size: 14px;">Winforms</a> <a href="/tags/Wordpress/" style="font-size: 18px;">Wordpress</a> <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/database/" style="font-size: 10px;">database</a> <a href="/tags/fuzzy-computing/" style="font-size: 10px;">fuzzy computing</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/import-csv/" style="font-size: 10px;">import csv</a> <a href="/tags/migrate/" style="font-size: 10px;">migrate</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/wordpress/" style="font-size: 10px;">wordpress</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/blog-2020-02-27-Lam-sao-de-tra-luong-lap-trinh-vien-it-hon/">Làm sao để trả lương lập trình viên ít hơn</a>
          </li>
        
          <li>
            <a href="/blog/blog-hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/blog/blog-2020-02-17-The-art-of-computer-prgramming-PREFACE/">The art of computer prgramming PREFACE</a>
          </li>
        
          <li>
            <a href="/blog/blog-2020-02-11-Geographical-Information-Systems-Part-1-Coursera-Week-1/">Geographical Information Systems Part 1 Coursera - Week 1</a>
          </li>
        
          <li>
            <a href="/blog/blog-2020-01-09-OWASP-Testing-Guide-2-Conduct-search-engine-discorvery-reconnaissance-for-information-leakage-OTG-INFO-001/">OWASP Testing Guide - 2 Conduct search engine discorvery/reconnaissance for information leakage (OTG-INFO-001) </a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 LuanTM<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>